Crack Detection
=======================

The integration test ``tests/test_DelaDect_crack_detection.py`` doubles as a handy recipe
book for the different evaluation modes. This page highlights the main patterns and how to
adapt them for your own runs.

Basic evaluation
----------------

.. code-block:: python

    from pathlib import Path

    data_root = Path("example_images") / "sample-1"
    test_dir = Path("reports") / "basic_functionality"
    test_dir.mkdir(parents=True, exist_ok=True)

    cracks, rho, theta = specimen.crack_eval(
        theta_fd=0,
        background=True,
        export_images=True,
        color_cracks='black',
        image_stack_orig=True,
        output_dir=str(test_dir),
    )

    rho_mm = specimen.pixels_to_length(rho)
    specimen.export_rho_th(rho_mm, theta, folder_name=str(test_dir),
                           file_name="crack_density_results.csv")
    specimen.save_cracks(
        cracks=cracks,
        folder_name=str(test_dir),
        file_name="detected_cracks.pkl",
    )

    specimen.upload_experimental_data(data_root / "experimental_data.csv")
    specimen.export_rho_th(rho_mm, theta, folder_name=str(test_dir),
                           file_name="crack_density_results_with_strain.csv")

- Saves per-frame crack overlays inside ``reports/Identified Cracks`` when
  ``export_images`` is enabled.
- Pickles the detected cracks with :meth:`~deladect.detection.Specimen.save_cracks` so you
  can reuse them in later sessions.
- Converts ``rho`` into millimetres through
  :meth:`~deladect.detection.Specimen.pixels_to_length` and writes CSVs with
  :meth:`~deladect.detection.Specimen.export_rho_th` (optionally after
  :meth:`~deladect.detection.Specimen.upload_experimental_data`).

Cross-ply laminates
-------------------

.. code-block:: python

    cracks_90, rho_90, th_90, cracks_0, rho_0, th_0 = specimen.crack_eval_crossply(
        export_images=True,
        save_cracks=True,
        output_dir=str(test_dir),
    )

- Caches ``cracks_0`` and ``cracks_90`` in ``Crack Detection/Identified Cracks`` so
  follow-up runs can skip detection and dive straight into analysis.
- Pair the output with :func:`~deladect.utils.DataProcessor.join_cracks` to build plots that
  contrast transverse and longitudinal cracks.

Post-processing and spacing analysis
------------------------------------

.. code-block:: python

    processed_data, filtered_cracks = specimen.crack_filtering_postprocessing(
        cracks_90,
        avg_crack_grouping_th_px=50,
        crack_length_th=threshold,
        remove_outliers=True,
    )
    results_mm = specimen.pixels_to_length(processed_data)
    specimen.export_crack_spacing(results_mm, folder_name=str(test_dir))

- Groups nearby segments to avoid double counting (configurable via
  ``avg_crack_grouping_th_px``).
- Removes outliers with an interquartile-range filter when ``remove_outliers`` is true.
- Exports crack-spacing summaries already converted to millimetres.

Visual reporting
----------------
The test suite also shows how to overlay multiple crack catalogues on a single frame using
Matplotlib:

.. code-block:: python

    joined_cracks = specimen.join_cracks(cracks_90, cracks_0)
    fig, ax = specimen.plot_cracks(
        image=specimen.image_stack_cut[-1],
        cracks=joined_cracks[-1],
        color='red'
    )
    fig.savefig(test_dir / "all_cracks_combined.png")

Use this pattern to build comparison panels, animations, or quick quality-control dashboards
before running larger batches.

Next steps
----------
- Explore :doc:`../detection` for the complete parameter list.
- Review the ``tests/test_results`` artefacts generated by ``pytest`` to see folder names and
  outputs that you can mirror in your own workflow.
